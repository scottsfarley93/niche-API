{
  "name": "jspath",
  "version": "0.3.3",
  "homepage": "https://github.com/dfilatov/jspath",
  "description": "DSL that enables you to navigate and find data within your JSON documents",
  "keywords": [
    "json",
    "path",
    "filter",
    "selection",
    "jspath",
    "jpath",
    "jsonpath"
  ],
  "author": {
    "name": "Dmitry Filatov",
    "email": "dfilatov@yandex-team.ru"
  },
  "contributors": [
    {
      "name": "Dmitry Filatov",
      "email": "dfilatov@yandex-team.ru"
    },
    {
      "name": "Marat Dulin",
      "email": "mdevils@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/dfilatov/jspath.git"
  },
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "0.9.1",
    "istanbul": "",
    "cliff": "",
    "benchmark": "",
    "uglify-js": "1.3.4"
  },
  "main": "index",
  "engines": {
    "node": ">= 0.4.0"
  },
  "scripts": {
    "test": "./node_modules/istanbul/lib/cli.js test test.js"
  },
  "enb": {
    "sources": [
      "lib/jspath.js"
    ]
  },
  "readme": "JSPath [![NPM version](https://badge.fury.io/js/jspath.png)](http://badge.fury.io/js/jspath) [![Build Status](https://secure.travis-ci.org/dfilatov/jspath.png)](http://travis-ci.org/dfilatov/jspath)\n============\n\nJSPath is a domain-specific language (DSL) that enables you to navigate and find data within your JSON documents. Using JSPath, you can select items of JSON in order to retrieve the data they contain.\n\nJSPath for JSON is like an XPath for XML.\n\nIt's heavily optimized both for Node.js and modern browsers.\n\nTable of Contents\n-----------------\n  * [Getting Started](#getting-started)\n    * [In the Node.js](#in-the-nodejs)\n    * [In the Browsers](#in-the-browsers)\n  * [Usage](#usage)\n    * [Quick example](#quick-example)\n  * [Documentation](#documentation)\n    * [Location path](#location-path)\n    * [Predicates](#predicates)\n    * [Object predicates](#object-predicates)\n      * [Comparison operators](#comparison-operators)\n      * [String comparison operators](#string-comparison-operators)\n      * [Logical operators](#logical-operators)\n      * [Arithmetic operators](#arithmetic-operators)\n      * [Operator precedence](#operator-precedence)\n    * [Positional predicates](#positional-predicates)\n    * [Multiple predicates](#multiple-predicates)\n    * [Substitutions](#substitutions)\n    * [Result](#result)\n\nGetting Started\n---------------\n###In the Node.js###\nYou can install using Node Package Manager (npm):\n\n    npm install jspath\n\n###In the Browsers###\n```html\n<script type=\"text/javascript\" src=\"jspath.min.js\"></script>\n```\nIt also supports RequireJS module format and [YM module](https://github.com/ymaps/modules) format.\n\nJSPath has been tested in IE6+, Mozilla Firefox 3+, Chrome 5+, Safari 5+, Opera 10+.\n\nUsage\n-----\n```javascript\nJSPath.apply(path, json);\n// or\nJSPath.apply(path, json, substs);\n```\nwhere:\n<table>\n  <tr>\n    <th></th>\n    <th>type</th>\n    <th>description</th>\n  <tr>\n    <td>path</td>\n    <td>String</td>\n    <td>path expression</td>\n  </tr>\n  <tr>\n    <td>json</td>\n    <td>any valid JSON</td>\n    <td>input JSON document</td>\n  </tr>\n  <tr>\n    <td>substs</td>\n    <td>Object</td>\n    <td>substitutions (optional)</td>\n  </tr>\n</table>\n\n###Quick example###\n```javascript\nJSPath.apply(\n    '.automobiles{.maker === \"Honda\" && .year > 2009}.model',\n    {\n        \"automobiles\" : [\n            { \"maker\" : \"Nissan\", \"model\" : \"Teana\", \"year\" : 2011 },\n            { \"maker\" : \"Honda\", \"model\" : \"Jazz\", \"year\" : 2010 },\n            { \"maker\" : \"Honda\", \"model\" : \"Civic\", \"year\" : 2007 },\n            { \"maker\" : \"Toyota\", \"model\" : \"Yaris\", \"year\" : 2008 },\n            { \"maker\" : \"Honda\", \"model\" : \"Accord\", \"year\" : 2011 }\n        ],\n        \"motorcycles\" : [{ \"maker\" : \"Honda\", \"model\" : \"ST1300\", \"year\" : 2012 }]\n    });\n```\nResult will be:\n```javascript\n['Jazz', 'Accord']\n```\n\nDocumentation\n-------------\nJSPath expression consists of two type of top-level expressions: location path (required) and predicates (optional).\n\n###Location path###\nTo select items in JSPath, you use a location path.\nThe location path consists of one or more location steps.\nEvery location step starts with dot (.) or two dots (..) depending on the item you're trying to select:\n  * .property &mdash; locates property immediately descended from context items\n  * ..property &mdash; locates property deeply descended from context items\n  * . &mdash; locates context items itself\n\nYou can use the wildcard symbol (*) instead of exact name of property:\n  * .* &mdash; locates all properties immediately descended from the context items\n  * ..* &mdash; locates all properties deeply descended from the context items\n \nIf you need to locate property containing non-alphanumerical characters, you can use quoted notation:\n  * .\"property with non-alphanumerical characters\"\n\nAlso JSPath allows to join several properties:\n  * (.property1 | .property2 | .propertyN) &mdash; locates property1, property2, propertyN immediately descended from context items\n  * or even (.property1 | .property2.property2_1.property2_1_1) &mdash; locates .property1, .property2.property2_1.property2_1_1 items\n\nYour location path can be absolute or relative.\nIf location path starts with the root (^) you are using an absolute location path &mdash; your location path begins from the root items.\n\nConsider the following JSON:\n```javascript\nvar doc = {\n    \"books\" : [\n        {\n            \"id\"     : 1,\n            \"title\"  : \"Clean Code\",\n            \"author\" : { \"name\" : \"Robert C. Martin\" },\n            \"price\"  : 17.96\n        },\n        {\n            \"id\"     : 2,\n            \"title\"  : \"Maintainable JavaScript\",\n            \"author\" : { \"name\" : \"Nicholas C. Zakas\" },\n            \"price\"  : 10\n        },\n        {\n            \"id\"     : 3,\n            \"title\"  : \"Agile Software Development\",\n            \"author\" : { \"name\" : \"Robert C. Martin\" },\n            \"price\"  : 20\n        },\n        {\n            \"id\"     : 4,\n            \"title\"  : \"JavaScript: The Good Parts\",\n            \"author\" : { \"name\" : \"Douglas Crockford\" },\n            \"price\"  : 15.67\n        }\n    ]\n};\n```\n\n####Examples####\n```javascript\n// find all books authors\nJSPath.apply('.books.author', doc);\n/* [{ name : 'Robert C. Martin' }, { name : 'Nicholas C. Zakas' }, { name : 'Robert C. Martin' }, { name : 'Douglas Crockford' }] */\n\n// find all books author names\nJSPath.apply('.books.author.name', doc);\n/* ['Robert C. Martin', 'Nicholas C. Zakas', 'Robert C. Martin', 'Douglas Crockford' ] */\n\n// find all names in books\nJSPath.apply('.books..name', doc);\n/* ['Robert C. Martin', 'Nicholas C. Zakas', 'Robert C. Martin', 'Douglas Crockford' ] */\n```\n\n###Predicates###\nJSPath predicates allow you to write very specific rules about items you'd like to select when constructing your expressions.\nPredicates are filters that restrict the items selected by location path. There're two possible types of predicates: object and positional.\n\n###Object predicates###\nObject predicates can be used in a path expression to filter a subset of items according to a boolean expressions working on a properties of each item.\nObject predicates are embedded in braces.\n\nBasic expressions in object predicates:\n  * numeric literals (e.g. 1.23)\n  * string literals (e.g. \"John Gold\")\n  * boolean literals (true/false)\n  * subpathes (e.g. .nestedProp.deeplyNestedProp)\n\nJSPath allows to use in predicate expressions following types of operators:\n  * comparison operators\n  * string comparison operators\n  * logical operators\n  * arithmetic operators\n\n####Comparison operators####\n\n<table>\n  <tr>\n    <td>==</td>\n    <td>Returns is true if both operands are equal</td>\n    <td>.books{.id == \"1\"}</td>\n  </tr>\n  <tr>\n    <td>===</td>\n    <td>Returns true if both operands are strictly equal with no type conversion</td>\n    <td>.books{.id === 1}</td>\n  </tr>\n  <tr>\n    <td>!=</td>\n    <td>Returns true if the operands are not equal</td>\n    <td>.books{.id != \"1\"}</td>\n  </tr>\n  <tr>\n    <td>!==</td>\n    <td>Returns true if the operands are not equal and/or not of the same type</td>\n    <td>.books{.id !== 1}</td>\n  </tr>\n  <tr>\n    <td>></td>\n    <td>Returns true if the left operand is greater than the right operand</td>\n    <td>.books{.id > 1}</td>\n  </tr>\n  <tr>\n    <td>>=</td>\n    <td>Returns true if the left operand is greater than or equal to the right operand</td>\n    <td>.books{.id >= 1}</td>\n  </tr>\n  <tr>\n    <td>&lt;</td>\n    <td>Returns true if the left operand is less than the right operand</td>\n    <td>.books{.id &lt; 1}</td>\n  </tr>\n  <tr>\n    <td>&lt;=</td>\n    <td>Returns true if the left operand is less than or equal to the right operand</td>\n    <td>.books{.id &lt;= 1}</td>\n  </tr>\n</table>\n\nComparison rules:\n  * if both operands to be compared are arrays, then the comparison will be\ntrue if there is an element in the first array and an element in the\nsecond array such that the result of performing the comparison of two elements is true\n  * if one operand is array and another is not, then the comparison will be true if there is element in\narray such that the result of performing the comparison of element and another operand is true\n  * primitives to be compared as usual javascript primitives\n\nIf both operands are strings, there're also available additional comparison operators:\n####String comparison operators####\n<table>\n  <tr>\n    <td>==</td>\n    <td>Like an usual '==' but case insensitive</td>\n    <td>.books{.title == \"clean code\"}</td>\n  </tr>\n  <tr>\n    <td>^==</td>\n    <td>Returns true if left operand value beginning with right operand value</td>\n    <td>.books{.title ^== \"Javascript\"}</td>\n  </tr>\n  <tr>\n    <td>^=</td>\n    <td>Like the '^==' but case insensitive</td>\n    <td>.books{.title ^= \"javascript\"}</td>\n  </tr>\n  <tr>\n    <td>$==</td>\n    <td>Returns true if left operand value ending with right operand value</td>\n    <td>.books{.title $== \"Javascript\"}</td>\n  </tr>\n  <tr>\n    <td>$=</td>\n    <td>Like the '$==' but case insensitive</td>\n    <td>.books{.title $= \"javascript\"}</td>\n  </tr>\n  <tr>\n    <td>*==</td>\n    <td>Returns true if left operand value contains right operand value</td>\n    <td>.books{.title *== \"Javascript\"}</td>\n  </tr>\n  <tr>\n    <td>*=</td>\n    <td>Like the '*==' but case insensitive</td>\n    <td>.books{.title *= \"javascript\"}</td>\n  </tr>\n</table>\n\n####Logical operators####\n\n<table>\n  <tr>\n    <td>&&</td>\n    <td>Returns true if both operands are true</td>\n    <td>.books{.price > 19 && .author.name === \"Robert C. Martin\"}</td>\n  </tr>\n  <tr>\n    <td>||</td>\n    <td>Returns true if either operand is true</td>\n    <td>.books{.title === \"Maintainable JavaScript\" || .title === \"Clean Code\"}</td>\n  </tr>\n  <tr>\n    <td>!</td>\n    <td>Returns true if operand is false</td>\n    <td>.books{!.title}</td>\n  </tr>\n</table>\n\nLogical operators convert their operands to boolean values using next rules:\n  * if operand is array (as you remember result of applying subpath is also array):\n    * if length of array greater than zero, result will be true\n    * else result will be false\n  * Casting with double NOT (!!) javascript operator to be used in any other cases.\n\n####Arithmetic operators####\n\n<table>\n  <tr>\n    <td>+</td>\n    <td>addition</td>\n  </tr>\n  <tr>\n    <td>-</td>\n    <td>subtraction</td>\n  </tr>\n  <tr>\n    <td>*</td>\n    <td>multiplication</td>\n  </tr>\n  <tr>\n    <td>/</td>\n    <td>division</td>\n  </tr>\n  <tr>\n    <td>%</td>\n    <td>modulus</td>\n  </tr>\n</table>\n\n####Operator precedence####\n<table>\n  <tr>\n    <td>1 (top)</td>\n    <td>! -<sup>unary</sup></td>\n  </tr>\n  <tr>\n    <td>2</td>\n    <td>* / %</td>\n  </tr>\n  <tr>\n    <td>3</td>\n    <td>+ -<sup>binary</sup></td>\n  </tr>\n  <tr>\n    <td>4</td>\n    <td>< <= > >=</td>\n  </tr>\n  <tr>\n    <td>5</td>\n    <td>== === != !== ^= ^== $== $= *= *==</td>\n  </tr>\n  <tr>\n    <td>6</td>\n    <td>&&</td>\n  </tr>\n  <tr>\n    <td>7</td>\n    <td>||</td>\n  </tr>\n</table>\n\nParentheses are used to explicitly denote precedence by grouping parts of an expression that should be evaluated first.\n\n####Examples####\n```javascript\n// find all book titles whose author is Robert C. Martin\nJSPath.apply('.books{.author.name === \"Robert C. Martin\"}.title', doc);\n/* ['Clean Code', 'Agile Software Development'] */\n\n// find all book titles with price less than 17\nJSPath.apply('.books{.price < 17}.title', doc);\n/* ['Maintainable JavaScript', 'JavaScript: The Good Parts'] */\n```\n\n###Positional predicates###\nPositional predicates allow you to filter items by their context position.\nPositional predicates are always embedded in square brackets.\n\nThere are four available forms:\n  * [ ````index````] &mdash; returns ````index````-positioned item in context (first item is at index 0), e.g. [3] returns fourth item in context\n  * [````index````:] &mdash; returns items whose index in context is greater or equal to ````index````, e.g. [2:] returns items whose index in context is greater or equal to 2\n  * [:````index````] &mdash; returns items whose index in context is smaller than ````index````, e.g. [:5] returns first five items in context\n  * [````indexFrom````:````indexTo````] &mdash; returns items whose index in context is greater or equal to ````indexFrom```` and smaller than ````indexTo````, e.g. [2:5] returns three items with indices 2, 3 and 4\n\nAlso you can use negative position numbers:\n  * [-1] &mdash; returns last item in context\n  * [-3:] &mdash; returns last three items in context\n\n####Examples####\n```javascript\n// find first book title\nJSPath.apply('.books[0].title', doc);\n/* ['Clean Code'] */\n\n// find first title of books\nJSPath.apply('.books.title[0]', doc);\n/* 'Clean Code' */\n\n// find last book title\nJSPath.apply('.books[-1].title', doc);\n/* ['JavaScript: The Good Parts'] */\n\n// find two first book titles\nJSPath.apply('.books[:2].title', doc);\n/* ['Clean Code', 'Maintainable JavaScript'] */\n\n// find two last book titles\nJSPath.apply('.books[-2:].title', doc);\n/* ['Agile Software Development', 'JavaScript: The Good Parts'] */\n\n// find two book titles from second position\nJSPath.apply('.books[1:3].title', doc);\n/* ['Maintainable JavaScript', 'Agile Software Development'] */\n```\n\n###Multiple predicates###\nYou can use more than one predicate. The result will contain only items that match all the predicates.\n\n####Examples####\n```javascript\n// find first book name whose price less than 15 and greater than 5\nJSPath.apply('.books{.price < 15}{.price > 5}[0].title', doc);\n/* ['Maintainable JavaScript'] */\n```\n\n###Substitutions###\nSubstitutions allow you to use runtime-evaluated values in predicates and pathes (as a path root).\n\n####Examples####\n```javascript\nvar path = '.books{.author.name === $author}.title';\n\n// find book name whose author Nicholas C. Zakas\nJSPath.apply(path, doc, { author : 'Nicholas C. Zakas' });\n/* ['Maintainable JavaScript'] */\n\n// find books name whose authors Robert C. Martin or Douglas Crockford\nJSPath.apply(path, doc, { author : ['Robert C. Martin', 'Douglas Crockford'] });\n/* ['Clean Code', 'Agile Software Development', 'JavaScript: The Good Parts'] */\n```\n\n###Result###\nResult of applying JSPath is always an array (empty, if found nothing), excluding case when the last predicate in top-level expression is a positional predicate with the exact index (e.g. [0], [5], [-1]).\nIn this case, result is an item at the specified index (````undefined```` if item hasn't found).\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/dfilatov/jspath/issues"
  },
  "_id": "jspath@0.3.3",
  "dist": {
    "shasum": "370d4c95efb8271a6504b1521e76692d79f2e5f7"
  },
  "_from": "jspath@^0.3.1",
  "_resolved": "https://registry.npmjs.org/jspath/-/jspath-0.3.3.tgz"
}
