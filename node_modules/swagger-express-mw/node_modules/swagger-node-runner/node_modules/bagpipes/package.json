{
  "name": "bagpipes",
  "version": "0.0.6",
  "description": "Less code, more flow. Let's dance!",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha test",
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/apigee-127/bagpipes.git"
  },
  "keywords": [
    "swagger",
    "plumbing",
    "pipes"
  ],
  "author": {
    "name": "Scott Ganyo",
    "email": "sganyo@apigee.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/apigee-127/bagpipes/issues"
  },
  "homepage": "https://github.com/apigee-127/bagpipes",
  "dependencies": {
    "async": "^1.4.2",
    "debug": "^2.1.2",
    "jspath": "^0.3.1",
    "lodash": "^3.5.0",
    "machinepack-http": "^2.3.0",
    "mustache": "^2.1.3",
    "pipeworks": "^1.3.0"
  },
  "devDependencies": {
    "should": "^7.1.0",
    "supertest": "^1.1.0"
  },
  "readme": "# Bagpipes\n\n### NOTE: THIS IS PRE-RELEASE SOFTWARE - SUBJECT TO CHANGE ###\n\n** Quick Reference links: **\n\n* [Installation](#installation)\n* [Pipes](#pipes)\n\t* [Parallel Execution](#parallel-execution)\n\t* [Context](#context)\n\t* [Error Handling](#error-handling)\n* [Fittings](#fittings)\n\t* [System Fittings](#system-fittings)\n\t* [User Defined Fittings](#user-defined-fittings)\n* [Debugging](#debugging)\n* [Change Log](#change-log)\n\n## What is Bagpipes?\n\nBagpipes was developed as a way to enable API flows and mashups to be created declaratively in YAML (or JSON)\nwithout writing code. It works a lot like functional programming... there's no global state, data is just\npassed from one function to the next down the line until we're done. (Similar to connect middleware.)\n\nFor example, to expose an API to get the latitude and longitude of an address using Google's Geocode API, one\ncould simply define a flow that looks like this:\n\n```yaml\n # 1. Define a http callout we'll use in our pipe\n google_geocode:\n   name: http\n   input:\n     url: http://maps.googleapis.com/maps/api/geocode/json?sensor=true  \n     params:\n       address: .request.parameters.address.value[0]\n\n # 2. Defined the pipe flow we'll play\n getAddressLocation:\n   - google_geocode            # call the fitting defined in this swagger\n   - path: body                # system fitting: get body from output\n   - parse: json               # body is a json string, parse to object\n   - path: results             # get results from body\n   - first                     # get first result\n   - path: geometry.location   # output = { lat: n, lng: n }\n```\n\nBut that's just a quick example, you can do much, much more... including filtering, error handling, and even\nparallel handling like mashup HTTP requests to multiple services.\n\n## Getting started\n\nHere's a simple, self-contained \"Hello, World\" example you can run:\n\n```js\nvar bagpipes = require('bagpipes');\n\nvar pipesDefs =  {\n  HelloWorld: [\n    { emit: 'Hello, World!' }\n  ]\n};\n\nvar pipesConfig = {};\nvar pipes = bagpipes.create(pipesDefs, pipesConfig);\nvar pipe = pipes.getPipe('HelloWorld');\n\nvar context = {};\npipes.play(pipe, context);\n\nconsole.log(context.output);\n```\n\nAs you can see, the pipe in the hello world above is defined programmatically. This is perfectly ok, but \nin general, you'll probably want load your pipe definitions from a YAML file something like this:\n\n```yaml\nHelloWorld:\n  - emit: 'Hello, World!'\n```\n\n```js\nvar bagpipes = require('bagpipes');\nvar yaml = require('js-yaml');\n\nvar pipesDefs = yaml.safeLoad(fs.readFileSync('HelloWorld.yaml'));\nvar pipes = bagpipes.create(pipesDefs, pipesConfig);\nvar pipe = pipes.getPipe('HelloWorld');\n\nvar context = {};\npipes.play(pipe, context);\n\nconsole.log(context.output);\n```\n\nEither way, have fun!\n\n## Fittings\n\nSo what are these things called \"fittings\"? Well, simply, if a pipe is a list of steps, a fitting describes\nwhat a single step actually accomplishes.\n\nLet's take a very simple example: Say we have some data that looks like this:\n\n```js\n[ { \"name\": \"Scott\", \"city\": \"Los Angeles\" }\n  { \"name\": \"Jeff\", \"city\": \"San Francisco\" } ]\n```\n\nNow, we'll create a pipe that just retrieves the first name. In the definition below, we've defined a pipe called\n\"getFirstUserName\" that consists of a couple of system-provided fittings:\n\n```yaml\n getFirstUserName:\n   - first\n   - path: name\n```\n\nThe \"first\" fitting selects the first element of an array passed in. The \"path\" fitting selects the \"user\" attribute\n from the object passed on by the first fitting. Thus, the result from our example is \"Scott\".\n\nOr, say we want to get all the names from our data as an array. We could simply do it like this:\n\n```yaml\n getUserNames:\n   - pick: name\n```\n\nObviously, these are trivial examples, but you can create pipes as long and as complex as you wish. In fact, you can\neven write your own special-purpose fittings. We'll get to that [later](#user-defined-fittings).\n\n### Fitting Definition\n\nWhen you want to use a fitting in your pipe, you have 2 options:\n\n1. A system or user fitting with zero or one input can be defined in-line, as we have shown above.\n2. A fitting with configuration or more complex inputs may need to be defined before use.\n\nLet's look at the 2nd type. Here's an example of a fitting that calls out to an API with a  URL that looks like\nsomething like this: http://maps.googleapis.com/maps/api/geocode/json?sensor=true?address=Los%20Angeles. And, of\ncourse, we'll want to make the address dynamic. This requires a a little bit of configuration: We need to tell the\n\"http\" fitting the URL, the operation, and what parameters to use (and how to get them):\n\n```yaml\n geocode:\n   name: http\n   input:\n     operation: get\n     url: http://maps.googleapis.com/maps/api/geocode/json\n     params:\n       sensor: true\n       address: .output.address[0]\n```\n\nAs you can see above, we've give our fitting a name (\"geocode\") and specified which type of fitting we're creating\n(a \"system\" fitting called \"http\"). This fitting requires several inputs including the HTTP operation, the URL, and\nparameters to pass. Each of these is just a static string in this case except for the \"address\" parameter. The\naddress is merely retrieved by picking the \"address\" property from the \"output\" object of whatever fitting came\nbefore it in the pipe. (Note: There are several options for input sources that will be defined later.)\n\nBy default, the output of this operation will be placed on the pipe in the \"output\" variable for the next fitting\nto use - or to be returned to the client if it's the last fitting to execute.\n\n-----\n\n# Reference\n\n## Pipe\n\nA Pipe is just defined in YAML as an Array. It can be reference by its key and can reference other pipes and fittings by\ntheir keys. Each step in a pipe may be one of the following:\n\n1. A pipe name\n2. A fitting name (with an optional value)\n3. An set of key/value pairs defining pipes to be performed in parallel\n\nIf a fitting reference includes a value, that value will be emitted onto the output for the fitting to consume. Most\nof the system fittings are able to operate solely on the output without any additional configuration - similar to a\nUnix pipe.\n\n### Parallel Execution\n\nGenerally, a pipe flows from top to bottom in serial manner. However, in some cases it is desirable to execute two\npipes in parallel (for example, a mashup of two external APIs).\n\nParallel execution of pipes can be done by using key/value pairs on the pipe in place of a single step. The output\nfrom each pipe will be assigned to the key associated with it. It's probably easiest to explain by example:\n\n```yaml\ngetRestaurantsAndWeather:\n  - getAddressLocation\n  - restaurants: getRestaurants\n    weather: getWeather\n```\n\nThis pipe will first flow through getAddressLocation step. Then, because the restaurants and weather keys are both on\nthe same step, it will execute the getRestaurants and getWeather pipes concurrently. The final output of this pipe\nwill be an object that looks like this: { restaurants: {...}, weather: {...} } where the values will be the output\nfrom the respective pipes.\n\n### Context\n\nThe context object that is passed through the pipe has the following properties that should be generally used by the\nfittings to accept input and deliver output via the pipe to other fittings or to the client:\n\n* **input**: the input defined in the fitting definition (string, number, object, array)\n* **output**: output to be delivered to the next fitting or client\n\nIn addition, the context has the following properties that should not be modified - and, in general, you shouldn't\nneed to access them at all:\n\n* **_errorHandler**: the pipe played if an error occurs in the pipe \n* **_finish**: a final fitting or pipe run once the pipe has finished (error or not) \n\nFinally, the context object itself will contain any properties that you've assigned to it via the 'output' option on \nyour fitting definition.\n\nNotes:\n\nThe context object is extensible as well. The names listed above as well as any name starting with '_' should be\nconsidered reserved, but you may assign other additional properties to the context should you need it for communication\nbetween fittings (see also the [memo](#memo) fitting).\n\n### Error Handling\n\nYou may install a custom error handler pipe by specifying them using the system [onError](#onError) fitting. (As\nyou might guess, this actually sets the _errorHandler property on context.)\n\n## Fittings\n\nAll fittings may have the following values (all of which are optional):\n\n* **type**: one of: system, user, swagger, node-machine\n* **name**: the name of the fitting of the type specified\n* **config**: static values passed to the fitting during construction\n* **input**: dynamic values passed to the fitting during execution\n* **output**: The name of the context key to which the output value is assigned\n\n#### Type\n\nIf type is omitted (as it must be for in-line usage), Bagpipes will first check the user fittings then the\nsystem fittings for the name and use the first fitting found. Thus be aware that if you define a fitting with the\nsame name as a system one, your fitting will override it.\n\n#### Input\n\nThe **input** may be a hash, array, or constant. The value or sub-values of the input is defined as either:\n\n* a constant string or number value\n* a **reference** to a value\n\nA **reference** is a value populated either from data on the request or from the output of previous fittings on the\npipe. It is defined like so:\n\n```yaml\n key:            # the variable name (key) on context.input to which the value is assigned\n   path: ''      # the variable to pick from context using [json path syntax](https://www.npmjs.com/package/jspath)\n   default: ''   # (optional) value to assign if the referenced value is undefined\n```\n\nNote: If there is no input definition, input will be assigned to the prior fitting's output. \n\nSee also [Context](#context) for more information.\n\n\n#### System Fittings\n\nThere are 2 basic types of system fittings: Internal fittings that just modify output in a flow and those that are\ncallouts to other systems. These are listed below by category:\n\n##### Internal Fittings\n\n###### amend: input\n\nAmend the pipe output by copying the fields from input. Overrides output. Input and output must be objects.\n\n###### emit: input\n\nEmit the fitting's input onto onto the pipe output.\n\n###### eval: 'script'\n\nUsed for testing and will likely be removed, but evaluates provided javascript directly.\n\n###### first\n\nSelect the first element from an array.\n\n###### jspath: jspath\n\nSelects output using [json path](https://www.npmjs.com/package/jspath) syntax.\n\n###### memo: key\n\nSaves the current context.output value to context[key]. Can be later retrieved via:\n\n```yaml\nemit:\n  name: key\n  in: context\n```\n\n###### omit: key | [ keys ]\n\nOmit the specified key or keys from an object.\n\n###### onError: pipename\n\nIn case of error, redirect the flow to the specified pipe.\n\n###### parallel: [ pipenames ]\n\nRun multiple pipe flows concurrently. Generally not used directly (use shorthand syntax on pipe).\n\n###### parse: json\n\nParses a String. Currently input must be 'json'.\n\n###### path: path\n\nSelects an element from an object by dot-delimited keys.\n\n###### pick: key | [ keys ]\n\nSelects only the specified key or keys from an object.\n\n###### render: string | @filename\n\nRender the object using a mustache template specified as the string or loaded from the filename in the user view\ndirectory.\n\n###### values\n\nSelect the values of an object as an array.\n\n##### Callout Fittings\n\n###### http\n\nMake a call to a URL.\n\nconfig keys:\n\n* baseUrl (optional)\n\ninput keys:\n\n* url    (optional: default = context.output)\n* method (optional: default = get) (get, post, put, delete, patch, etc.)\n* params (optional) key/value pairs\n* headers (optional) key/value pairs\n\noutput:\n\n{\n  status: statusCode\n  headers: JSON string\n  body: JSON string\n}\n\n\n#### User Defined Fittings\n\nThe user fitting is a custom function you can write and place in the fittings directory. It requires the following\nvalues:\n\n* **name**: the javascript module name in the 'fittings' folder\n\n```\n exampleUserFitting:\n   name: customizeResponse\n```\n\nJavascript implementation:\n\nA user fitting is a fitting defined in the user's fittings directory. It exposes a creation function that accepts a\nfittingDefinition and the swagger-pipes configuration. This function is executed during parsing. Thus, it should access \nthe fittingDef.config (if any) and create any static resources at this time.\n\nThe creation function returns an execution function that will called during pipe flows. This function accepts a\ncontext object and a standard javascript asynchronous callback. When executed, this function should perform its\nintended function and then call the callback function with (error, response) when complete. \n\nHere's an example fitting that will query Yelp for businesses near a location with an input of \n{ latitude: n, longitude: n }:\n\n```js\nvar Yelp = require('yelp');\nvar util = require('util');\n\nmodule.exports = function create(fittingDef, bagpipes) {\n\n  var yelp = Yelp.createClient(fittingDef.config);\n\n  return function yelp_search(context, cb) {\n\n    var input = context.input;\n\n    var options = {\n      term: input.term,\n      ll: util.format('%s,%s', input.latitude, input.longitude)\n    };\n\n    yelp.search(options, function(error, data) {\n\n      if (error) { return cb(error); }\n      if (data.error) { return cb(data.error); }\n\n      cb(null, data.businesses);\n    });\n  }\n};\n```\n\n#### Swagger fittings\n\n** Experimental **\n\nYou can access Swagger APIs by simply loading that Swagger. A Swagger fitting expects this:\n\n* **type**: 'swagger'\n* **url**: url to the swagger definition\n\n```yaml\n exampleSwaggerFitting:\n   type: swagger\n   url: http://petstore.swagger.io/v2/swagger.json\n```\n\n#### Node-machine fittings\n\n** Experimental **\n\nA node-machine is a self-documenting component format that we've adapted to the a127 (see [http://node-machine.org]()).\nYou can use a node-machine just by using 'npm install' and declaring the fitting. The fitting definition expects a\nminimum of:\n\n* **type**: 'node-machine'\n* **machinepack**: the name of the machinepack\n* **machine**: the function name (or id) of the machine\n\n```yaml\n exampleNodeMachineFitting:\n   type: node-machine\n   machinepack: machinepack-github\n   machine: list-repos\n```\n\n#### Connect-middleware fittings\n\n** Experimental **\n\nConnect-middleware fittings are special-purpose fittings provided as a convenience if you want to call out to any\nconnect middleware that you have. Before calling a connect-middleware fitting, you must set a `request` and `response` \nproperty on context with appropriate values from your request chain. These will be passed to the associated connect \nmiddleware. Also, you must have passed in to the bagpipes configuration a value for connectMiddlewareDirs. \nBe aware, however, as these controllers almost certainly interact directly with the response and aren't designed for \nuse within the Bagpipes system, either appropriately wrap the response object or use this option with caution.\n\n* **type**: 'connect-middleware'\n* **module**: the name of the file or module to load from your middleware directory\n* **function**: the exported function to call on the middleware\n\n```yaml\n exampleMiddlewareFitting:\n   type: connect-middleware\n   module: my_module\n   function: someFunction\n```\n\n## Debugging\n\nCurrently, debugging is limited to reading log entries and the debugger. However, there is a lot of information\navailable to you by enabling the DEBUG log. By enabling the DEBUG=pipes log, you will be able to see the entire\nflow of the swagger-pipes system sent to the console:\n\n    DEBUG=pipes\n\nYou can get more debug information from the fittings with:\n\n    DEBUG=pipes:fittings\n\nYou can also emit the actual output from each step by enabling pipes:content:\n\n    DEBUG=pipes:content\n\nFinally, you can enable all the pipes debugging by using a wildcard:\n\n    DEBUG=pipes*\n\n## Change Log\n\n\n\nEnjoy!\n",
  "readmeFilename": "README.md",
  "_id": "bagpipes@0.0.6",
  "dist": {
    "shasum": "e6b08bd5cc2f45af76bdb2152bb99ac71299cc72"
  },
  "_from": "bagpipes@^0.0.6",
  "_resolved": "https://registry.npmjs.org/bagpipes/-/bagpipes-0.0.6.tgz"
}
